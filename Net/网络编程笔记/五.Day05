回顾
1.
2.epoll方法实现IO多路复用
 *效率高
 *触发方式更多
 *监控的IO更多

3.struct模块
 功能：python数据和bytes字节串之间的转换
 Struct（fmt）生成数据结构对象
 pack（）数据打包
 unpack（）数据解析 
4.本地套接字

5.多任务编程
    什么是多任务
    并发和并行
6.进程
    什么是进程？
    进程的状态？

    进程状态查看：ps -aux  ----->STAT列
        S 等待态
        R 运行态
        Z 僵尸

        l 有多线程的
        + 前台进程

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
一.进程的运行特征
    1.进程可以使用计算机多核资源
    2.进程是计算机资源分配的最小单元
    3.进程之间的运行互不影响，各自独立
    4.每个进程拥有各自独立的空间，各自使用各自空间的内容

二.基于fork的进程创建
    pid = os.fork()
    功能：创建新的进程
    返回值：整数，如果创建进程失败返回一个负数
           如果成功，新进程得到0，原进程得到新进程的PID号
    
    总结：*子进程会复制父进程的全部内存空间，从fork的下一句开始执行。
        * 父子进程各自运行不影响，顺序不确定
        * 利用父子进程中fork返回值的差异，配合if语句让父子进程执行不同内容几乎是固定搭配
        * 父进程fork之前开辟的空间，子进程也会拥有，父子进程在各自空间操作不会互相影响
        * 父子进程有各自特有的内容，PID，PCB。。。
三.进程相关函数
    1.os.getpid()
        功能：获取一个进程的PID值
        返回值：返回当前进程的PID
    
    2.os.getppid()
        功能:或许一个父进程的PID值
        返回值：返回父进程的PID
    
    3.os._exit(status)
        功能：结束一个进程
        参数：进程结束状态 整数

    4.sys.exit([status])
        功能：结束一个进程
        参数：默认为0，整数表示退出状态，字符串表示退出是打印的内容
    
四.孤儿和僵尸
    1.孤儿进程：父进程先于子进程退出，此时子进程成为孤儿进程。
    特点：孤儿进程会被系统进程收养，此时系统进程会成为孤儿进程新的父进程。
    孤儿进程退出时，系统进程会处理退出行为

    2.僵尸进程：子进程先于父进程退出，父进程没有处理子进程退出行为，此时子进程就会成为僵尸进程
    特点：僵尸进程虽然已经结束，但是会存留部分进程信息在内存中，大量的僵尸会浪费系统内存。

    3.僵尸进程处理
        【1】使用wait()函数处理子进程退出
            pid,status = os.wait()
            功能：阻塞等待子进程的退出
            返回值：pid   退出的子进程PID
                  status 子进程的退出状态

            pid,status = os.waitpid(pid,option)
            功能：非阻塞等待子进程的退出
            参数：pid   -1   等待任意子进程退出
                       >0   表示等待指定子进程
                       option  0           表示阻塞
                               os.WNOHANG  表示非阻塞
            返回值：pid   退出的子进程PID
                  status 子进程的退出状态
        【2】创建二级子进程
            1.父进程创建子进程wait等待回收
            2.子进程创建二级子进程后退出
            3.二级子进程成为孤儿，和父进程一起完成事件

        【3】信号处理
            原理：子进程退出会发送信号给父进程，如果父进程忽略子进程信号，则系统会自动处理子进程的退出。

            方法： import signal
                  signal.signal(signal.SIGCHID,signal.SIG_IGN)
            特点:  非阻塞
                  使用该方法，可以处理所有的子进程退出

五.群聊服务
    1.服务：类似qq群聊功能
        【1】有人进入聊天室需要输入姓名，姓名不能重复
        【2】有人进入聊天室，其他人能收到通知
            ××× 进入聊天室
        【3】一个人发消息，其他人会收到消息
            ×××：×××××××
        【4】有人退出聊天室，则其他人会收到通知
            ×××离开了聊天室
        【5】扩展功能：服务器可以向所有群用户发送公告。
            管理员消息：×××××××××××
    2.确定技术模型
        【1】消息的网络传输：socket-->udp
        【2】发送模型：
            转发     客户端-->服务端-->客户端
        【3】服务端用户存储 {name:addr}
        【4】收发关系处理：多进程分别处理消息接收和发送
        发送

    3.整体设计
        【1】封装方法，函数
    
    4.注意点
        【1】写一个模块测试一个模块
        【2】注释的添加
    5.具体实现
        【1】网络连接搭建
        【2】进入聊天室
            1.客户端： *输入姓名
                      *将姓名发送给服务器
                      *接受反馈
                      *OK则进入，否则重新输入
            2.服务端：*接受姓名
                     *判断是否允许进入，通知客户端
                     *不允许则结束，允许则将信息保存
                     到数据字典
                     *将登录信息告诉其他人
        【3】实现聊天
            1.客户端：接受聊天内容请求
            2.服务端：发送聊天内容
                     接受别人的聊天内容
        【4】退出聊天室
        【5】管理员公告
